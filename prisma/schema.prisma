generator client {
    provider = "prisma-client"
    output   = "../generated/prisma"
}

datasource db {
    provider = "postgresql"
}

//* Type - PostVisibility
enum PostVisibility {
    PRIVATE
    PUBLIC
}

//* Type - PostStatus
enum PostStatus {
    PENDING_REVIEW
    APPROVED
    REJECTED
}

//* Type - ReactionType
enum ReactionType {
    POSITIVE
    NEGATIVE
}

//* Type - NotificationType
enum NotificationType {
    ANNOUNCEMENT
    REVIEW_REQUEST
    POST_REVIEW
    POST_REACTION
    POST_COMMENT
    COMMENT_REACTION
    COMMENT_REPLY
}

//* Type - NotificationSubjectType
enum NotificationSubjectType {
    PLATFORM
    POST
    COMMENT
}

//* Type - ProfileGender
enum ProfileGender {
    MALE
    FEMALE
    LGBTQ_PLUS
}

//* Type - ProfilePronouns
enum ProfilePronouns {
    HE_HIM
    SHE_HER
    THEY_THEM
}

//* Model - User
model User {
    id            String    @id
    name          String
    email         String    @unique
    emailVerified Boolean   @default(false)
    image         String?
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    sessions      Session[]
    accounts      Account[]
}

//* Model - Account
model Account {
    id                    String    @id
    accountId             String
    providerId            String
    userId                String
    user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken           String?
    refreshToken          String?
    idToken               String?
    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    password              String?
    createdAt             DateTime  @default(now())
    updatedAt             DateTime  @updatedAt

    @@index([userId])
}

//* Model - Profile
model Profile {
    id          String          @id @default(uuid()) @db.Uuid
    userId      String          @unique @db.Uuid
    displayName String          @db.VarChar(50)
    phone       String?         @db.VarChar(17)
    bio         String?         @db.VarChar(200)
    isVerified  Boolean         @default(false)
    picture     String
    banner      String?
    gender      ProfileGender
    pronouns    ProfilePronouns
    website     String?
    facebook    String?
    linkedin    String?
    xTwitter    String?
    instagram   String?
    github      String?
    updatedAt   DateTime        @updatedAt
}

//* Model - Session
model Session {
    id        String   @id
    expiresAt DateTime
    token     String   @unique
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
}

//* Model - Verification
model Verification {
    id         String   @id
    identifier String
    value      String
    expiresAt  DateTime
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    @@index([identifier])
}

//* Model - Post
model Post {
    id                String         @id @default(uuid()) @db.Uuid
    authorId          String         @db.Uuid
    thumbnail         String?
    title             String         @db.VarChar(100)
    content           String?
    tags              String[]       @default([])
    visibility        PostVisibility @default(PUBLIC)
    readTime          String         @db.VarChar(7)
    views             Int            @default(0)
    isFeatured        Boolean        @default(false)
    reviewRequestedAt DateTime       @default(now())
    reviewedAt        DateTime?
    updatedAt         DateTime       @updatedAt
    status            PostStatus     @default(PENDING_REVIEW)
    reactions         Reaction[]
    comments          Comment[]
}

//* Model - Reaction
model Reaction {
    id        String       @id @default(uuid()) @db.Uuid
    userId    String       @db.Uuid
    postId    String?      @db.Uuid
    post      Post?        @relation(fields: [postId], references: [id])
    commentId String?      @db.Uuid
    comment   Comment?     @relation(fields: [commentId], references: [id])
    type      ReactionType
    reactedAt DateTime     @default(now())
}

//* Model - Comment
model Comment {
    id        String     @id @default(uuid()) @db.Uuid
    userId    String     @db.Uuid
    postId    String     @db.Uuid
    post      Post       @relation(fields: [postId], references: [id])
    parentId  String?    @db.Uuid
    parent    Comment?   @relation(name: "CommentReplies", fields: [parentId], references: [id])
    content   String
    createdAt DateTime   @default(now())
    updatedAt DateTime   @updatedAt
    reactions Reaction[]
    replies   Comment[]  @relation(name: "CommentReplies")
}

//! Future-planned Model
//* Model - Notification
/**
 * model Notification {
 * id          String                  @id @default(uuid()) @db.Uuid
 * receiverId  String                  @db.Uuid
 * senderId    String                  @db.Uuid
 * subjectId   String                  @db.Uuid
 * type        NotificationType
 * subjectType NotificationSubjectType
 * hasSeen     Boolean                 @default(false)
 * createdAt   DateTime                @default(now())
 * }
 */
